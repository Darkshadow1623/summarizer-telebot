# -*- coding: utf-8 -*-
"""audiotrans (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SlKjqIpNU3W5e5AxltpMF07JtyynhCBG
"""

!pip install pyTelegramBotAPI nltk gtts pydub python-docx pdfminer.six googletrans==4.0.0-rc1
!pip install python-docx
!pip install docx2txt

"""AUDIO AND VIDEO"""

!pip install rouge-score
!pip install PyPDF2

"""final rouge score, mos, Processing Time, Visual Inspection, User Feedback"""

import telebot
import nltk
from gtts import gTTS
from PIL import Image, ImageDraw, ImageFont
import cv2
import numpy as np
import os
from rouge_score import rouge_scorer
from googletrans import Translator
import requests
from bs4 import BeautifulSoup
import time
from PyPDF2 import PdfFileReader
import docx

# Initialize the Telegram bot
bot = telebot.TeleBot("6414110367:AAEdLJLl8iEFMR7KUgZsDaC8aLzySNtZsH0")

# Download NLTK resources
nltk.download('punkt')

# Initialize global variables for tracking processing time and user feedback
processing_times = {}
user_feedback = {}

def summarize_text(input_text):
    start_time = time.time()
    sentences = nltk.sent_tokenize(input_text)
    summary = ' '.join(sentences[:3])
    end_time = time.time()
    processing_time = end_time - start_time
    return summary, processing_time

def text_to_speech(text, language_code, audio_path):
    start_time = time.time()
    tts = gTTS(text=text, lang=language_code, slow=False)
    tts.save(audio_path)
    end_time = time.time()
    processing_time = end_time - start_time
    return processing_time

def text_to_video(summarized_text, video_filename):
    start_time = time.time()
    # Set video dimensions and frame rate
    width, height = 1280, 720
    fps = 10  # Decreased frame rate for slower movement
    frame_duration = 3  # Duration each frame is displayed (in seconds)

    # Create an empty list to store frames
    frames = []

    # Set font properties
    font = ImageFont.truetype("/content/sample_data/OpenSans-Regular.ttf", 50)
    text_color = (255, 255, 255)  # White color

    # Split summarized text into lines to fit within video width
    lines = []
    line = ''
    for word in summarized_text.split():
        if font.getsize(line + word)[0] <= width:
            line += f"{word} "
        else:
            lines.append(line)
            line = f"{word} "
    lines.append(line)

    # Create frames with summarized text
    for line in lines:
        # Create a blank frame
        frame = np.zeros((height, width, 3), dtype=np.uint8)

        # Convert frame to PIL Image
        pil_frame = Image.fromarray(frame)

        # Get drawing context
        draw = ImageDraw.Draw(pil_frame)

        # Draw text on frame
        draw.text((10, 10), line, font=font, fill=text_color)

        # Convert back to numpy array and append to frames list
        frame = np.array(pil_frame)
        frames.extend([frame] * int(frame_duration * fps))

    # Write frames to video file
    out = cv2.VideoWriter(video_filename, cv2.VideoWriter_fourcc(*'mp4v'), fps, (width, height))
    for frame in frames:
        out.write(frame)
    out.release()
    end_time = time.time()
    processing_time = end_time - start_time
    return processing_time

def extract_text_from_url(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    paragraphs = soup.find_all('p')
    text = '\n'.join([p.get_text() for p in paragraphs])
    return text

def extract_text_from_pdf(file_path):
    with open(file_path, 'rb') as file:
        pdf_reader = PdfFileReader(file)
        text = ''
        for page in range(pdf_reader.numPages):
            text += pdf_reader.getPage(page).extractText()
    return text

def extract_text_from_docx(file_path):
    doc = docx.Document(file_path)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return '\n'.join(full_text)

# Start the bot
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    bot.reply_to(message, "Welcome to the Text Summarization Chatbot! Please send me a text, a URL, a PDF, or a Word file (max 3000 words) to summarize.")

@bot.message_handler(content_types=['text'])
def summarize_and_convert(message):
    input_text = message.text

    # Check if the input is a URL
    if input_text.startswith('http'):
        original_text = extract_text_from_url(input_text)
    elif input_text.endswith('.pdf'):
        original_text = extract_text_from_pdf(input_text)
    elif input_text.endswith('.docx'):
        original_text = extract_text_from_docx(input_text)
    else:
        original_text = input_text

    if len(original_text.split()) > 3000:
        bot.reply_to(message, "The input text is too long. Please provide a text, URL, PDF, or Word file with a maximum of 3000 words.")
        return

    summarized_text, summarization_time = summarize_text(original_text)

    # Calculate ROUGE score
    scorer = rouge_scorer.RougeScorer(['rouge1', 'rougeL'], use_stemmer=True)
    scores = scorer.score(original_text, summarized_text)
    rouge_score = scores['rougeL'].fmeasure

    # Store processing time
    processing_times[message.chat.id] = {
        'summarization_time': summarization_time,
        'audio_processing_time': None,
        'video_processing_time': None
    }

    # Store user feedback placeholder
    user_feedback[message.chat.id] = {}

    # Convert summarized text to audio
    language_keyboard = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True, resize_keyboard=True)
    language_keyboard.add("en", "ta", "hi", "ml", "te", "kn", "gu")  # Add more languages as needed
    language_prompt = bot.send_message(message.chat.id, "Please choose a language for audio conversion:", reply_markup=language_keyboard)
    bot.register_next_step_handler(language_prompt, process_language_selection, summarized_text, original_text, rouge_score)

def process_language_selection(message, summarized_text, original_text, rouge_score):
    chosen_language = message.text.lower()

    if chosen_language in ["en", "ta", "hi", "ml", "te", "kn", "gu"]:
        language_code = chosen_language[:2]  # Extract language code (e.g., 'en', 'fr', 'es')

        # Translate the summarized text to the selected language
        translator = Translator()
        translated_text = translator.translate(summarized_text, dest=language_code).text

        # Convert translated text to audio
        audio_path = "summarized_audio.mp3"
        audio_processing_time = text_to_speech(translated_text, language_code, audio_path)
        processing_times[message.chat.id]['audio_processing_time'] = audio_processing_time
        bot.send_audio(message.chat.id, open(audio_path, 'rb'))

        # Ask if the user wants to convert audio to video
        video_conversion_keyboard = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True, resize_keyboard=True)
        video_conversion_keyboard.add("Yes", "No")
        video_conversion_prompt = bot.send_message(message.chat.id, "Do you want to convert the summarized text to video?", reply_markup=video_conversion_keyboard)
        bot.register_next_step_handler(video_conversion_prompt, process_video_conversion_selection, summarized_text, original_text, rouge_score)

    else:
        bot.reply_to(message, "Invalid language selection. Please choose a valid language.")

def process_video_conversion_selection(message, summarized_text, original_text, rouge_score):
    user_response = message.text.lower()
    if user_response == "yes":
        # Convert summarized text to video
        video_filename = "summarized_video.mp4"
        video_processing_time = text_to_video(summarized_text, video_filename)
        processing_times[message.chat.id]['video_processing_time'] = video_processing_time
        send_video_to_telegram(message.chat.id, video_filename)

        bot.send_message(message.chat.id, f"ROUGE Score: {rouge_score}")

        # Request user feedback
        feedback_keyboard = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True, resize_keyboard=True)
        feedback_keyboard.add("1", "2", "3", "4", "5")
        feedback_prompt = bot.send_message(message.chat.id, "Please rate the quality of the summary (1 - Poor, 5 - Excellent):", reply_markup=feedback_keyboard)
        bot.register_next_step_handler(feedback_prompt, process_user_feedback, message.chat.id)

    elif user_response == "no":
        bot.reply_to(message, "Okay, not converting summarized text to video. Type /start to summarize again.")
    else:
        bot.reply_to(message, "Invalid response. Please choose either 'Yes' or 'No'.")

def process_user_feedback(message, chat_id):
    user_rating = message.text
    user_feedback[chat_id]['rating'] = user_rating
    bot.send_message(chat_id, "Thank you for your feedback!")

    # Ask if the user wants to start a new session or end the current session
    session_end_keyboard = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True, resize_keyboard=True)
    session_end_keyboard.add("Start New Session", "End Session")
    session_end_prompt = bot.send_message(chat_id, "Do you want to start a new session or end the current session?", reply_markup=session_end_keyboard)
    bot.register_next_step_handler(session_end_prompt, handle_session_end_decision, chat_id)

def handle_session_end_decision(message, chat_id):
    decision = message.text.lower()
    if decision == "start new session":
        bot.send_message(chat_id, "Starting a new session. Type /start to begin.")
    elif decision == "end session":
        bot.send_message(chat_id, "Ending the current session. Type /start to begin a new session.")
        # Clear stored data for the current session
        del processing_times[chat_id]
        del user_feedback[chat_id]
    else:
        bot.send_message(chat_id, "Invalid choice. Please type /start to begin a new session.")

# Function to send video to Telegram
def send_video_to_telegram(chat_id, video_file):
    bot.send_chat_action(chat_id, 'upload_video')
    video = open(video_file, 'rb')
    bot.send_video(chat_id, video)
    video.close()

# Start the bot
bot.polling()